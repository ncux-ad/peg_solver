# Руководство по производительности Peg Solitaire Solver

## Методы ускорения поиска решений

### 1. Lookup Table (Быстрее всего! ⚡)
**LookupSolver** - база известных решений
- **Скорость**: O(1) для известных позиций
- **Использование**: автоматически для стандартных позиций
- **Преимущества**: мгновенное решение после первого поиска

### 2. Каноническая форма (8x сокращение пространства)
- Приводит позицию к канонической форме (8 симметрий)
- Уменьшает количество проверяемых состояний в 8 раз
- Используется во всех решателях по умолчанию

### 3. Мультипоточность

#### ParallelSolver (Multiprocessing)
- **Метод**: `multiprocessing` - распределяет первые ходы между процессами
- **Использование**: для глубоких позиций (> 25 колышков)
- **Скорость**: ~N раз (где N = количество ядер CPU)
- **Overhead**: средний (сериализация/десериализация)

#### ParallelBeamSolver (Threading/ProcessPool)
- **Метод**: параллелит обработку каждого уровня beam
- **Использование**: для больших beam_width (> 500)
- **Скорость**: ~2-4x на многоядерных системах
- **Overhead**: высокий для маленьких задач (лучше для больших)

### 4. Оптимизации кода

#### Cython (26x ускорение)
- **FastBitBoard**: критические операции в Cython
- **Производительность**: 2.3M ops/s vs 87K ops/s (Python)
- **Использование**: автоматически, если скомпилирован

#### BitBoard представление
- **O(1)** операции: ход = 3 XOR операции
- **Быстрое хеширование**: O(1) вместо O(N)
- **Экономия памяти**: 8 байт вместо ~100 байт на состояние

#### Zobrist Hashing
- **Инкрементальное обновление**: O(1) вместо O(N)
- **Быстрая проверка посещённых**: hash lookup вместо полного сравнения

### 5. Эвристики и pruning

#### Pagoda Function
- **Отсечение**: недостижимые позиции (экономия ~30-50% поиска)
- **Использование**: во всех решателях (мягкий для произвольных позиций)

#### Pattern Database
- **Предвычисленные эвристики**: для 5 регионов доски
- **Улучшение A***: более точная оценка расстояния до цели
- **Скорость**: O(1) lookup

### 6. Сравнение решателей

| Решатель | Скорость | Использование |
|----------|----------|---------------|
| **LookupSolver** | ⚡⚡⚡ Мгновенно | Известные позиции |
| **Beam Search** | ⚡⚡ Быстрый | Универсальный (рекомендуется) |
| **Parallel Beam** | ⚡⚡ Средний | Большие позиции (>25 колышек) |
| **DFS** | ⚡ Медленный | Маленькие позиции (<10 колышек) |
| **Parallel DFS** | ⚡⚡ Средний | Глубокие позиции |

### 7. Рекомендации

#### Для английской доски (32 колышка):
```python
solver = LookupSolver()  # Мгновенно из базы
# или
solver = BeamSolver(beam_width=500)  # ~6 секунд
```

#### Для произвольных позиций (20-30 колышков):
```python
solver = GovernorSolver()  # Автоматический выбор
# или
solver = ParallelBeamSolver(beam_width=500, num_workers=4)  # Многопоточный
```

#### Для маленьких позиций (<10 колышков):
```python
solver = DFSSolver()  # Быстрое исчерпывающее решение
```

### 8. Настройка производительности

#### Увеличение beam_width:
```python
BeamSolver(beam_width=1000)  # Больше состояний = больше шансов найти решение
```

#### Увеличение количества workers:
```python
ParallelBeamSolver(num_workers=8)  # Все ядра CPU
```

#### Отключение Pagoda (если блокирует):
```python
DFSSolver(use_pagoda=False)  # Для произвольных позиций
```

### 9. Известные проблемы производительности

- **Threading в Python**: GIL ограничивает параллелизм для CPU-bound задач
- **Multiprocessing overhead**: сериализация/десериализация замедляет маленькие задачи
- **Pagoda pruning**: слишком строгий для произвольных позиций (исправлено)

### 10. Планы по улучшению

- [ ] GPU ускорение (CUDA/OpenCL) для массовой генерации ходов
- [ ] Более умное распределение задач в ProcessPoolExecutor
- [ ] Кэширование оценок состояний
- [ ] Инкрементальная компиляция Cython для всех критических функций
- [ ] Использование numba для JIT компиляции
